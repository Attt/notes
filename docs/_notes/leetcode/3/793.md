[793. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/)

### 思路

这题k的规模来看明显不可能模拟去判断，所以应该是数学规律题。。

先模拟一下看看能不能推导出规律

```text
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
...
9! = xx780
10! = xx7800
11! = xx5800
12! = xx600
13! = xx800
14! = xx200
15! = xx000

从这里可以发现
   0个0的时候，0! 1! 2! 3! 4!，有5个数
   1个0的时候，5! 6! 7! 8! 9!，有5个数
   2个0的时候，10! 11! 12! 13! 14!，也有5个数

看上去最多只有5个数，但关键是为什么呢。。。

    11! = 11 x 10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x 1
    素因数分解：
    11! = 11 x (2 x 5) x (3 x 3) x (2 x 2 x 2) x 7 x (2 x 3) x 5 x (2 x 2) x 3 x 2 x 1
```

可以看出来，每当有2x5的时候就会多一个0，且2和5是素数，2的数量又远多于5，所以只能是5的倍数，所以两个数量的0之间有5个数。

但是题例中不是有0的情况嘛？

仔细观察，分解后的式子5能够增加0，但也可以一下子增加两个0，因为2数量远多于5，例子k=5的时候满足条件的数为0个，是因为本来有5个0的情况下已经到了5 * 5=25!的阶乘，但正因为25能分解成5 * 5，所以多出来一个5..，就多出来一个0了，也就是从4个0（24!）直接变为了6个0（25！）

所以这题就变成递增的序列中，对其进行素因数分解，其中5不可能出现的个数是多少的问题。
当k等于这个个数时，解为0，其余的解都是5

而在递增序列中找某一个值，通常用二分法来减少时间复杂度


这里要确定一下右边界，也就是递增序列的上限，由上面可以知道阶乘数里因数5的个数就是k的个数，也就是有多少个0

```text
10! = (5! 10!)
    = 1 + 1
    = 2
24! = (5! 10! 15! 20!)
    = 1 + 1 + 1 + 1
    = 4
25! = (5! 10! 15! 20! 25!)
    = 1 + 1 + 1 + 1 + 2
    = 6

50! = (5! 10! 15! 20! 25! 30! 35! 40! 45! 50!)
    = 1 + 1 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 2
    = 12

x! = loop if x!=0: (x = x/5) + x/5

因为每个5至少都会贡献一个0，所以阶乘数的范围一定小于0的个数k*5，即
    5 * k_min < x < 5 * k_max
```

所以计算x的阶乘有多少个0可以：

```java
private int zCnt(int x){
    int cnt = 0;
    while(x != 0){
        cnt += (x = x / 5);
    }
    return cnt;
}
```

### 解

```java
class Solution {
    public int preimageSizeFZF(int k) {
        long l = 0, r = 5L * k;
        while(l <= r){
            long m = (r - l) / 2 + l;
            int cnt = zCnt(m);
            if(cnt < k){
                l = m + 1;
            }else if(cnt > k){
                r = m - 1;
            }else if(cnt == k){
                return 5;
            }
        }
        return 0;
    }

    private int zCnt(long x){
        int cnt = 0;
        while(x != 0){
            cnt += (x = x / 5);
        }
        return cnt;
    }
}
```

### 总结
- 这题需要对素因数分解有一定了解
- 单调函数查找问题用二分
- 注意int的范围，防止溢出（10进制21亿，也就是10位的十进制就可以用long了）